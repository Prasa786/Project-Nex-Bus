package com.nexbus.nexbus_backend.service;

import com.nexbus.nexbus_backend.dto.RoleDTO;
import com.nexbus.nexbus_backend.exception.ResourceNotFoundException;
import com.nexbus.nexbus_backend.model.Role;
import com.nexbus.nexbus_backend.repository.RoleRepository;
import com.nexbus.nexbus_backend.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class RoleService {

    private static final Logger logger = LoggerFactory.getLogger(RoleService.class);

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private UserRepository userRepository;

    public List<RoleDTO> findAll() {
        logger.debug("Fetching all roles");
        return roleRepository.findAll().stream()
            .map(this::mapToDTO)
            .collect(Collectors.toList());
    }

    public RoleDTO findById(Integer id) {
        logger.debug("Fetching role with ID: {}", id);
        Role role = roleRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Role", "ID", id));
        return mapToDTO(role);
    }

    public RoleDTO save(RoleDTO roleDTO) {
        logger.debug("Saving new role: {}", roleDTO.getRoleName());
        try {
            Role.RoleName.valueOf(roleDTO.getRoleName());
        } catch (IllegalArgumentException e) {
            logger.error("Invalid role name: {}", roleDTO.getRoleName());
            throw new IllegalArgumentException("Invalid role name: " + roleDTO.getRoleName());
        }

        Role role = mapToEntity(roleDTO);
        role.setRoleId(null); // Ensure ID is generated by the database
        role = roleRepository.save(role);
        logger.info("Role saved successfully: {}", role.getRoleName());
        return mapToDTO(role);
    }

    public RoleDTO update(Integer id, RoleDTO roleDTO) {
        logger.debug("Updating role with ID: {}", id);
        Role existingRole = roleRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Role", "ID", id));

        try {
            Role.RoleName newRoleName = Role.RoleName.valueOf(roleDTO.getRoleName());
            existingRole.setRoleName(newRoleName);
        } catch (IllegalArgumentException e) {
            logger.error("Invalid role name: {}", roleDTO.getRoleName());
            throw new IllegalArgumentException("Invalid role name: " + roleDTO.getRoleName());
        }

        roleRepository.save(existingRole);
        logger.info("Role updated successfully: {}", existingRole.getRoleName());
        return mapToDTO(existingRole);
    }

    public void deleteById(Integer id) {
        logger.debug("Deleting role with ID: {}", id);
        Role role = roleRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Role", "ID", id));

        long userCount = userRepository.countByRoleId(id);
        if (userCount > 0) {
            logger.error("Cannot delete role with ID: {} as it is assigned to {} users", id, userCount);
            throw new IllegalStateException("Cannot delete role as it is assigned to " + userCount + " users");
        }

        roleRepository.deleteById(id);
        logger.info("Role deleted successfully with ID: {}", id);
    }

    private RoleDTO mapToDTO(Role role) {
        RoleDTO dto = new RoleDTO();
        dto.setRoleId(role.getRoleId());
        dto.setRoleName(role.getRoleName().name());
        if (role.getCreatedAt() != null) {
            dto.setCreatedAt(role.getCreatedAt().toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDateTime());
        }
        return dto;
    }

    private Role mapToEntity(RoleDTO dto) {
        Role role = new Role();
        role.setRoleName(Role.RoleName.valueOf(dto.getRoleName()));
        return role;
    }
}